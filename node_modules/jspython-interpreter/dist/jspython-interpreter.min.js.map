{"version":3,"file":"jspython-interpreter.min.js","sources":["../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/common/utils.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["export enum OperationTypes {\r\n    Arithmetic, Assignment, Comparison, Logical, Membership\r\n};\r\n\r\nexport type AssignmentOperators = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"++\" | \"--\";\r\nexport type ArithmeticOperators = \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"**\" | \"//\";\r\nexport type ComparisonOperators = \">\" | \">=\" | \"==\" | \"!=\" | \"<>\" | \"<\" | \"<=\";\r\nexport type LogicalOperators = \"and\" | \"or\"; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = \"in\";\r\n\r\nexport type Operators = AssignmentOperators | ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\n\r\nexport const OperatorsMap: Record<Operators, OperationTypes> = {\r\n    \"+\": OperationTypes.Arithmetic,\r\n    \"-\": OperationTypes.Arithmetic,\r\n    \"*\": OperationTypes.Arithmetic,\r\n    \"/\": OperationTypes.Arithmetic,\r\n    \"%\": OperationTypes.Arithmetic,\r\n    \"**\": OperationTypes.Arithmetic,\r\n    \"//\": OperationTypes.Arithmetic,\r\n\r\n    \">\": OperationTypes.Comparison,\r\n    \">=\": OperationTypes.Comparison,\r\n    \"==\": OperationTypes.Comparison,\r\n    \"!=\": OperationTypes.Comparison,\r\n    \"<>\": OperationTypes.Comparison,\r\n    \"<\": OperationTypes.Comparison,\r\n    \"<=\": OperationTypes.Comparison,\r\n\r\n    \"and\": OperationTypes.Logical,\r\n    \"or\": OperationTypes.Logical,\r\n    // \"not\": OperationTypes.Logical,\r\n    // \"not in\": OperationTypes.Logical,\r\n\r\n    \"in\": OperationTypes.Membership,\r\n\r\n    \"=\": OperationTypes.Assignment,\r\n    \"+=\": OperationTypes.Assignment,\r\n    \"-=\": OperationTypes.Assignment,\r\n    \"*=\": OperationTypes.Assignment,\r\n    \"/=\": OperationTypes.Assignment,\r\n    \"++\": OperationTypes.Assignment,\r\n    \"--\": OperationTypes.Assignment,\r\n};\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators = ArithmeticOperators | ComparisonOperators | LogicalOperators | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Record<ExpressionOperators, ExpressionOperation> = {\r\n    \"+\": (l, r) => arithmeticOperation(l, r, \"+\"),\r\n    \"-\": (l, r) => arithmeticOperation(l, r, \"-\"),\r\n    \"/\": (l, r) => arithmeticOperation(l, r, \"/\"),\r\n    \"*\": (l, r) => arithmeticOperation(l, r, \"*\"),\r\n    \"%\": (l, r) => arithmeticOperation(l, r, \"%\"),\r\n    \"**\": (l, r) => arithmeticOperation(l, r, \"**\"),\r\n    \"//\": (l, r) => arithmeticOperation(l, r, \"//\"),\r\n\r\n    \">\": (l, r) => comparissonOperation(l, r, \">\"),\r\n    \">=\": (l, r) => comparissonOperation(l, r, \">=\"),\r\n    \"<\": (l, r) => comparissonOperation(l, r, \"<\"),\r\n    \"<=\": (l, r) => comparissonOperation(l, r, \"<=\"),\r\n    \"==\": (l, r) => comparissonOperation(l, r, \"==\"),\r\n    \"!=\": (l, r) => comparissonOperation(l, r, \"!=\"),\r\n    \"<>\": (l, r) => comparissonOperation(l, r, \"<>\"),\r\n\r\n    \"and\": (l, r) => logicalOperation(l, r, \"and\"),\r\n    \"or\": (l, r) => logicalOperation(l, r, \"or\"),\r\n    // \"not\": (l, r) => logicalOperation(l, r, \"not\"),\r\n    // \"not in\": (l, r) => logicalOperation(l, r, \"not in\"),\r\n\r\n    \"in\": (l, r) => membershipOperation(l, r, \"in\")\r\n}\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n    if(typeof l === 'string'){\r\n        return (l as string).includes(String(r));\r\n    }\r\n\r\n    if(Array.isArray(l)){\r\n        return (l as any[]).includes(r);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n    switch (op) {\r\n        case 'and':\r\n            return l as any && r as any;\r\n\r\n        case 'or':\r\n            return (l as any) || (r as any);\r\n    }\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n    switch (op) {\r\n        case '==':\r\n            return l as any === r as any;\r\n\r\n        case '!=':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '<>':\r\n            return (l as any) !== (r as any);\r\n\r\n        case '>':\r\n            return (l as number) > (r as number);\r\n\r\n        case '<':\r\n            return (l as number) < (r as number);\r\n\r\n        case '>=':\r\n            return (l as number) >= (r as number);\r\n\r\n        case '<=':\r\n            return (l as number) <= (r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n\r\n    switch (op) {\r\n        case '+':\r\n            return l as any + r as any;\r\n\r\n        case '-':\r\n            return (l as any) - (r as any);\r\n\r\n        case '*':\r\n            return (l as number) * (r as number);\r\n\r\n        case '/':\r\n            return (l as number) / (r as number);\r\n\r\n        case '%':\r\n            return (l as number) % (r as number);\r\n\r\n        case '**':\r\n            return Math.pow(l as number, r as number);\r\n    }\r\n\r\n    throw new Error(`Unknown operation '${op}'`);\r\n}","import { OperationTypes, Operators, OperatorsMap } from \"./operators\";\r\n\r\nexport enum TokenTypes {\r\n    Identifier = 0,\r\n    Keyword = 1,\r\n    Separator = 2,\r\n    Operator = 3,\r\n    LiteralNumber = 4,\r\n    LiteralBool = 5,\r\n    LiteralString = 6,\r\n    LiteralNull = 7,\r\n    Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n    return tokenType === TokenTypes.LiteralString\r\n        || tokenType === TokenTypes.LiteralNumber\r\n        || tokenType === TokenTypes.LiteralBool\r\n        || tokenType === TokenTypes.LiteralNull;\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n    return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n    return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n    return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n    return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n    return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n    return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n    return token[1][4];\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n    const result: Token[][] = [];\r\n\r\n    if (!tokens.length) { return []; }\r\n\r\n    const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n\r\n    let start = 0;\r\n    for (let i = 0; i < sepIndexes.length; i++) {\r\n        const ind = sepIndexes[i];\r\n        result.push(tokens.slice(start, ind));\r\n        start = ind + 1\r\n    }\r\n\r\n    result.push(tokens.slice(start, tokens.length));\r\n    return result;\r\n}\r\n\r\nexport function findTokenValueIndex(tokens: Token[], predicate: (value: TokenValue) => boolean, start = 0): number {\r\n    for (let i = start; i < tokens.length; i++) {\r\n        if (getTokenType(tokens[i]) === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (getTokenValue(tokens[i]) === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (getTokenValue(tokens[i]) === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (getTokenValue(tokens[i]) === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(getTokenValue(tokens[i]))) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nexport function findTokenValueIndexes(tokens: Token[], predicate: (value: TokenValue) => boolean): number[] {\r\n    const opIndexes: number[] = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const tValue = getTokenValue(tokens[i]);\r\n        const tType = getTokenType(tokens[i]);\r\n\r\n        if (tType === TokenTypes.LiteralString) { continue; }\r\n\r\n        if (tValue === '(') {\r\n            i = skipInnerBrackets(tokens, i, '(', ')');\r\n        } else if (tValue === '[') {\r\n            i = skipInnerBrackets(tokens, i, '[', ']');\r\n        } else if (tValue === '{') {\r\n            i = skipInnerBrackets(tokens, i, '{', '}');\r\n        } else if (predicate(tValue)) {\r\n            opIndexes.push(i);\r\n        }\r\n    }\r\n\r\n    return opIndexes;\r\n}\r\n\r\nexport function findOperators(tokens: Token[], operationType: OperationTypes | null = null): number[] {\r\n    return !operationType ? findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] !== undefined)\r\n        :\r\n        findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] === operationType);\r\n}\r\n\r\nfunction skipInnerBrackets(tokens: Token[], i: number, openChar: string, closeChar: string): number {\r\n    let innerBrackets = 0;\r\n    while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n        if (i + 1 >= tokens.length) {\r\n            throw new Error(`Closing '${closeChar}' is missing`);\r\n        }\r\n\r\n        const tokenValue = getTokenValue(tokens[i]);\r\n        if (tokenValue === openChar) { innerBrackets++; }\r\n        if (tokenValue === closeChar) { innerBrackets--; }\r\n    }\r\n    return i;\r\n};\r\n","import { ExpressionOperators, LogicalOperators, OperationTypes, Operators } from \"./operators\";\r\nimport { getTokenLoc, getTokenValue, Token } from \"./token-types\";\r\n\r\nexport type AstNodeType = 'assign' | 'binOp' | 'const'\r\n    | 'logicalOp'\r\n    | 'getSingleVar' | 'setSingleVar' | 'dotObjectAccess' | 'bracketObjectAccess'\r\n    | 'funcCall' | 'funcDef' | 'arrowFuncDef'\r\n    | 'createObject' | 'createArray'\r\n    | 'if' | 'for' | 'while' | 'tryExcept' | 'raise'\r\n    | 'import' | 'comment'\r\n    | 'return' | 'continue' | 'break';\r\n\r\nexport interface NameAlias {\r\n    name: string,\r\n    alias: string | undefined\r\n}\r\n\r\nexport interface ExceptBody {\r\n    error: NameAlias;\r\n    body: AstNode[];\r\n}\r\n    \r\nexport interface FuncDefNode {\r\n    params: string[];\r\n    funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n    nullCoelsing: boolean | undefined\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n    name: AstNode;\r\n    value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n    loc: Uint16Array | undefined = undefined;\r\n    constructor(public type: AstNodeType) { }\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n    constructor(\r\n        public target: AstNode,\r\n        public source: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('assign');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n    public value: number | string | boolean | null;\r\n\r\n    constructor(token: Token) {\r\n        super('const');\r\n        this.value = getTokenValue(token);\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n    constructor(public comment: string, public loc: Uint16Array) {\r\n        super('comment');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n    constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n        super('return');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n    constructor(public errorName: string, public errorMessage: string | undefined, public loc: Uint16Array) {\r\n        super('raise');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n    constructor() {\r\n        super('continue');\r\n    }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n    constructor() {\r\n        super('break');\r\n    }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n    public name: string;\r\n    constructor(token: Token) {\r\n        super('setSingleVar');\r\n        this.name = token[0] as string\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n    public nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n        super('funcCall');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public isAsync: boolean, public loc: Uint16Array) {\r\n        super('funcDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n    constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n        super('arrowFuncDef');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n    constructor(\r\n        public conditionNode: AstNode,\r\n        public ifBody: AstNode[],\r\n        public elseBody: AstNode[] | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('if');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n    constructor(\r\n        public tryBody: AstNode[],\r\n        public exepts: ExceptBody[],\r\n        public elseBody: AstNode[] | undefined,\r\n        public finallyBody: AstNode[] | undefined,\r\n        \r\n        public loc: Uint16Array) {\r\n        super('tryExcept');\r\n        this.loc = loc\r\n    }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n    constructor(public sourceArray: AstNode, public itemVarName: string, public body: AstNode[], public loc: Uint16Array) {\r\n        super('for');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n    constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n        super('while');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n    constructor(public module: NameAlias, public body: AstBlock, public parts: NameAlias[] | undefined = undefined, public loc: Uint16Array) {\r\n        super('import');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n    name: string;\r\n    nullCoelsing: boolean | undefined = undefined;\r\n\r\n    constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n        super('getSingleVar');\r\n        this.name = token[0] as string;\r\n        this.nullCoelsing = nullCoelsing;\r\n        this.loc = getTokenLoc(token);\r\n    }\r\n}\r\n\r\nexport class DotObjectAccessNode extends AstNode {\r\n    constructor(public nestedProps: AstNode[], public loc: Uint16Array) {\r\n        super('dotObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n    constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n        super('createObject');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n    constructor(public items: AstNode[], public loc: Uint16Array) {\r\n        super('createArray');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BracketObjectAccessNode extends AstNode {\r\n    constructor(\r\n        public propertyName: string,\r\n        public bracketBody: AstNode,\r\n        public nullCoalescing: boolean | undefined = undefined,\r\n        public loc: Uint16Array) {\r\n        super('bracketObjectAccess');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n    node: AstNode,\r\n    op: LogicalOperators | undefined\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n    constructor(public items: LogicalNodeItem[],\r\n        public loc: Uint16Array) {\r\n        super('logicalOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n    constructor(\r\n        public left: AstNode,\r\n        public op: ExpressionOperators,\r\n        public right: AstNode,\r\n        public loc: Uint16Array) {\r\n        super('binOp');\r\n        this.loc = loc;\r\n    }\r\n}\r\n\r\nexport interface AstBlock {\r\n    name: string;\r\n    type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch'\r\n    funcs: FunctionDefNode[];\r\n    body: AstNode[];\r\n}\r\n\r\n\r\n","import { Token } from \"./token-types\";\r\n\r\nexport function parseDatetimeOrNull(value: string | Date): Date | null {\r\n    if (!value) { return null; }\r\n    if (value instanceof Date && !isNaN(value.valueOf())) { return value; }\r\n    // only string values can be converted to Date\r\n    if (typeof value !== 'string') { return null; }\r\n\r\n    const strValue = String(value);\r\n    if (!strValue.length) { return null; }\r\n\r\n    const parseMonth = (mm: string): number => {\r\n        if (!mm || !mm.length) {\r\n            return NaN;\r\n        }\r\n\r\n        const m = parseInt(mm, 10);\r\n        if (!isNaN(m)) {\r\n            return m - 1;\r\n        }\r\n\r\n        // make sure english months are coming through\r\n        if (mm.startsWith('jan')) { return 0; }\r\n        if (mm.startsWith('feb')) { return 1; }\r\n        if (mm.startsWith('mar')) { return 2; }\r\n        if (mm.startsWith('apr')) { return 3; }\r\n        if (mm.startsWith('may')) { return 4; }\r\n        if (mm.startsWith('jun')) { return 5; }\r\n        if (mm.startsWith('jul')) { return 6; }\r\n        if (mm.startsWith('aug')) { return 7; }\r\n        if (mm.startsWith('sep')) { return 8; }\r\n        if (mm.startsWith('oct')) { return 9; }\r\n        if (mm.startsWith('nov')) { return 10; }\r\n        if (mm.startsWith('dec')) { return 11; }\r\n\r\n        return NaN;\r\n    };\r\n\r\n    const correctYear = (yy: number) => {\r\n        if (yy < 100) {\r\n            return yy < 68 ? yy + 2000 : yy + 1900;\r\n        } else {\r\n            return yy;\r\n        }\r\n    };\r\n\r\n    const validDateOrNull =\r\n        (yyyy: number, month: number, day: number, hours: number, mins: number, ss: number): Date | null => {\r\n            if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) { return null; }\r\n\r\n            const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n            return !isNaN(dd.valueOf()) ? dd : null;\r\n        };\r\n\r\n    const strTokens = strValue.replace('T', ' ').toLowerCase().split(/[: /-]/);\r\n    const dt = strTokens.map(parseFloat);\r\n\r\n    // try ISO first\r\n    let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then UK\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    // then US\r\n    d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n    if (d) { return d; }\r\n\r\n    return null;\r\n}\r\n\r\nfunction jspyErrorMessage(error: string, module: string, line: number, column: number, message: string): string {\r\n    return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyTokenizerError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyParserError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyParserError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n    constructor(public module: string, public line: number, public column: number, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyEvalError\", module, line, column, message);\r\n        Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n    }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n   \r\n    constructor(public module: string, public line: number, public column: number, public name: string, public message: string) {\r\n        super();\r\n        this.message = jspyErrorMessage(\"JspyError\", module || 'name.jspy', line, column, message);\r\n        Object.setPrototypeOf(this, JspyError.prototype);\r\n    }\r\n}\r\n","\r\nexport interface BlockContext {\r\n    moduleName: string;\r\n    blockScope: Scope;\r\n    returnCalled?: boolean;\r\n    breakCalled?: boolean;\r\n    continueCalled?: boolean;\r\n    returnObject?: any;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n    return {\r\n        moduleName: context.moduleName,\r\n        blockScope: context.blockScope.clone()\r\n    } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n    private readonly scope: Record<string, unknown> = {};\r\n\r\n    constructor(initialScope: Record<string, unknown>) {\r\n        this.scope = { ...initialScope };\r\n    }\r\n\r\n    getScope(): Record<string, unknown> {\r\n        return this.scope;\r\n    }\r\n\r\n    clone(): Scope {\r\n        return new Scope(this.scope);\r\n    }\r\n    set(key: string, value: unknown, path: string = '\\\\'): void {\r\n        this.scope[key] = value;\r\n    }\r\n\r\n    get(key: string, path: string = '\\\\'): unknown {\r\n        return this.scope[key];\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    IfNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\nexport class Evaluator {\r\n\r\n    evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            newScope.set(funcDef.funcAst.name,\r\n                (...args: unknown[]): unknown => this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n            );\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                // we can't use it here, because loader has to be promise\r\n                throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n            }\r\n            try {\r\n                lastResult = this.evalNode(node, blockContext);\r\n\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return this.evalBlock(ast, blockContext);\r\n    }\r\n\r\n    private invokeFunction(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc: { moduleName: string, line: number, column: number }): unknown {\r\n\r\n        if (fps.length === 0) { return func(); }\r\n        if (fps.length === 1) { return func(fps[0]); }\r\n        if (fps.length === 2) { return func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n        if (node.type === 'import') {\r\n            // skip this for now. As modules are implemented externally\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;// cloneContext(blockContext);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null)\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                this.evalNode(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (this.evalNode(whileNode.condition, blockContext)) {\r\n                this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n\r\n            const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = this.evalNode(binOpNode.left, blockContext);\r\n            var right = this.evalNode(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = this.evalNode(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n\r\n            return this.invokeFunction(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[1]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = this.evalNode(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = this.evalNode(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = this.evalNode(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = this.evalNode(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as any).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[this.evalNode(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof func !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || []\r\n                    startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[1]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(this.evalNode(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import {\r\n    ArrowFuncDefNode,\r\n    AssignNode, AstBlock, AstNode, BinOpNode, BracketObjectAccessNode, ConstNode, CreateArrayNode,\r\n    CreateObjectNode, DotObjectAccessNode, ForNode, FuncDefNode, FunctionCallNode, FunctionDefNode, GetSingleVarNode,\r\n    getStartLine,\r\n    getTokenLoc,\r\n    IfNode, ImportNode, IsNullCoelsing, LogicalOpNode, OperationFuncs, Primitive, RaiseNode, ReturnNode, SetSingleVarNode, TryExceptNode, WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext, Scope } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n\r\n    private moduleParser: (modulePath: string) => Promise<AstBlock> = () => Promise.reject('Module parser is not registered!');\r\n    private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n    registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n        this.moduleParser = moduleParser;\r\n        return this;\r\n    }\r\n\r\n    registerBlockContextFactory(blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext): EvaluatorAsync {\r\n        this.blockContextFactory = blockContextFactory;\r\n        return this;\r\n    }\r\n\r\n    async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n        let lastResult = null;\r\n\r\n        for (let node of ast?.funcs || []) {\r\n            const funcDef = node as FunctionDefNode;\r\n\r\n            // a child scope needs to be created here\r\n            const newScope = blockContext.blockScope;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n            newScope.set(funcDef.funcAst.name, invoker);\r\n        }\r\n\r\n        for (const node of ast.body) {\r\n            if (node.type === 'comment') { continue; }\r\n            if (node.type === 'import') {\r\n                const importNode = node as ImportNode;\r\n\r\n                if (!importNode.module.name.startsWith('/') /* || !importNode.module.name.endsWith('.jspy')*/) {\r\n                    // it is not JSPY imort. It is JS and should be handled externally\r\n                    continue;\r\n                }\r\n\r\n                if (typeof this.blockContextFactory !== 'function') {\r\n                    throw new Error('blockContextFactory is not initialized');\r\n                }\r\n\r\n                const moduleAst = await this.moduleParser(importNode.module.name);\r\n                const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n                await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n                let scope = blockContext.blockScope.getScope();\r\n\r\n                if (!importNode.parts?.length) {\r\n                    // if no parts, then we need to assign to a separate object\r\n                    scope = {};\r\n                    blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);\r\n                }\r\n\r\n                this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, importNode.parts?.map(p => p.name));\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                lastResult = await this.evalNodeAsync(node, blockContext);\r\n                if (blockContext.returnCalled) {\r\n                    const res = blockContext.returnObject;\r\n                    // stop processing return\r\n                    if (ast.type == 'func' || ast.type == 'module') {\r\n                        blockContext.returnCalled = false;\r\n                        blockContext.returnObject = null;\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                if (blockContext.continueCalled) {\r\n                    break;\r\n                }\r\n                if (blockContext.breakCalled) {\r\n                    break;\r\n                }\r\n            } catch (err) {\r\n                const loc = node.loc ? node.loc : [0, 0]\r\n                if (err instanceof JspyError) {\r\n                    throw err;\r\n                } else if (err instanceof JspyEvalError) {\r\n                    throw err;\r\n                } else {\r\n                    throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], err.message || err)\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastResult;\r\n    }\r\n\r\n    private assignFunctionsToScope(scope: Record<string, unknown>, moduleBlockContext: BlockContext,\r\n        moduleAst: AstBlock, parts?: string[]): void {\r\n\r\n        const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n        for (let i = 0; i < funcs.length; i++) {\r\n            const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n            const invoker = (funcDef.isAsync) ?\r\n                async (...args: unknown[]): Promise<unknown> => await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n                : (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n            scope[funcDef.funcAst.name] = invoker;\r\n        }\r\n    }\r\n\r\n    private defaultModuleName(name: string): string {\r\n        return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'))\r\n    }\r\n\r\n    private async jspyFuncInvokerAsync(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): Promise<unknown> {\r\n\r\n        const ast = Object.assign({}, funcDef.funcAst);\r\n        ast.type = 'func';\r\n\r\n        const blockContext = cloneContext(context);\r\n\r\n        // set parameters into new scope, based incomming arguments        \r\n        for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n            const argValue = args?.length > i ? args[i] : null;\r\n            blockContext.blockScope.set(funcDef.params[i], argValue);\r\n        }\r\n\r\n        return await this.evalBlockAsync(ast, blockContext);\r\n    }\r\n\r\n    private async invokeFunctionAsync(func: (...args: unknown[]) => unknown, fps: unknown[],\r\n        loc?: { moduleName: string, line: number, column: number }): Promise<unknown> {\r\n\r\n        if (fps.length === 0) { return await func(); }\r\n        if (fps.length === 1) { return await func(fps[0]); }\r\n        if (fps.length === 2) { return await func(fps[0], fps[1]); }\r\n        if (fps.length === 3) { return await func(fps[0], fps[1], fps[2]); }\r\n        if (fps.length === 4) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3]);\r\n        }\r\n        if (fps.length === 5) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4]);\r\n        }\r\n\r\n        if (fps.length === 6) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5]);\r\n        }\r\n\r\n        if (fps.length === 7) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6]);\r\n        }\r\n\r\n        if (fps.length === 8) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7]);\r\n        }\r\n\r\n        if (fps.length === 9) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8]);\r\n        }\r\n\r\n        if (fps.length === 10) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9]);\r\n        }\r\n\r\n        if (fps.length === 11) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10]);\r\n        }\r\n\r\n        if (fps.length === 12) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11]);\r\n        }\r\n\r\n        if (fps.length === 13) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12]);\r\n        }\r\n\r\n        if (fps.length === 14) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13]);\r\n        }\r\n\r\n        if (fps.length === 15) {\r\n            return await func(fps[0], fps[1], fps[2], fps[3], fps[4], fps[5], fps[6], fps[7], fps[8], fps[9], fps[10], fps[11], fps[12], fps[13], fps[14]);\r\n        }\r\n\r\n        throw Error('Function has too many parameters. Current limitation is 15');\r\n\r\n    }\r\n\r\n    private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n        if (node.type === 'import') {\r\n            throw new Error('Import should be defined at the start');\r\n        }\r\n\r\n        if (node.type === 'comment') {\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'if') {\r\n            const ifNode = node as IfNode;\r\n            if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock, blockContext);\r\n            } else if (ifNode.elseBody) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock, blockContext);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'raise') {\r\n            const raiseNode = node as RaiseNode;\r\n            const err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, raiseNode.errorMessage || \"\");\r\n            throw err;\r\n        }\r\n\r\n        if (node.type === 'tryExcept') {\r\n            const tryNode = node as TryExceptNode;\r\n            try {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock, blockContext);\r\n\r\n                if (tryNode.elseBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n            catch (err) {\r\n                // catches here all exceptions. Including JSPY Eval errors\r\n                const name = (err instanceof JspyError) ? (err as JspyError).name : typeof (err);\r\n                const message = (err instanceof JspyError) ? (err as JspyError).message : err?.message ?? String(err);\r\n                const moduleName = (err instanceof JspyError) ? (err as JspyError).module : 0;\r\n                const line = (err instanceof JspyError) ? (err as JspyError).line : 0;\r\n                const column = (err instanceof JspyError) ? (err as JspyError).column : 0;\r\n\r\n                const firstExept = tryNode.exepts[0];\r\n                const catchBody = firstExept.body;\r\n                const ctx = blockContext;\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", { name, message, line, column, moduleName })\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock, ctx);\r\n                ctx.blockScope.set(firstExept.error?.alias || \"error\", null);\r\n            }\r\n            finally {\r\n                if (tryNode.finallyBody?.length || 0 > 0) {\r\n                    await this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.finallyBody } as AstBlock, blockContext);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'return') {\r\n            const returnNode = node as ReturnNode;\r\n            blockContext.returnCalled = true;\r\n            blockContext.returnObject = returnNode.returnValue ?\r\n                await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n                : null;\r\n\r\n            return blockContext.returnObject;\r\n        }\r\n\r\n        if (node.type === 'continue') {\r\n            blockContext.continueCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'break') {\r\n            blockContext.breakCalled = true;\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'for') {\r\n            const forNode = node as ForNode;\r\n\r\n            const array = await this.evalNodeAsync(forNode.sourceArray, blockContext) as unknown[] | string;\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                blockContext.blockScope.set(forNode.itemVarName, item);\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock, blockContext);\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n            return;\r\n        }\r\n\r\n        if (node.type === 'while') {\r\n            const whileNode = node as WhileNode;\r\n\r\n            while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n                await this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock, blockContext);\r\n\r\n                if (blockContext.continueCalled) { blockContext.continueCalled = false; }\r\n                if (blockContext.breakCalled) { break; }\r\n            }\r\n            if (blockContext.breakCalled) { blockContext.breakCalled = false; }\r\n\r\n            return;\r\n        }\r\n\r\n        if (node.type === \"const\") {\r\n            return (node as ConstNode).value;\r\n        }\r\n\r\n        if (node.type === \"getSingleVar\") {\r\n            const name = (node as GetSingleVarNode).name;\r\n            const value = blockContext.blockScope.get(name);\r\n\r\n            if (value === undefined) {\r\n                if (name.charAt(name.length - 1) === ';') {\r\n                    throw new Error(`Unexpected ';' in the end.`);\r\n                } else {\r\n                    throw new Error(`Variable '${name}' is not defined.`);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n\r\n        if (node.type === \"binOp\") {\r\n            const binOpNode = (node as BinOpNode);\r\n            var left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n            var right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n            return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n        }\r\n\r\n        if (node.type === \"logicalOp\") {\r\n            const logicalGroups = (node as LogicalOpNode);\r\n            let ind = 0;\r\n            let gResult: any = true;\r\n\r\n            while (ind < logicalGroups.items.length) {\r\n                const eg = logicalGroups.items[ind++];\r\n\r\n                gResult = await this.evalNodeAsync(eg.node, blockContext)\r\n\r\n                if (eg.op === 'and' && !gResult) { return false; }\r\n                if (eg.op === 'or' && gResult) { return gResult; }\r\n            }\r\n\r\n            return gResult;\r\n        }\r\n\r\n        if (node.type === \"arrowFuncDef\") {\r\n            const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n            return (...args: unknown[]): unknown => new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n        }\r\n\r\n        if (node.type === \"funcCall\") {\r\n            const funcCallNode = node as FunctionCallNode;\r\n            const func = blockContext.blockScope.get(funcCallNode.name) as (...args: unknown[]) => unknown;\r\n\r\n            if (typeof func !== 'function') {\r\n                throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n            }\r\n\r\n            const pms = [];\r\n            for (let p of funcCallNode.paramNodes || []) {\r\n                pms.push(await this.evalNodeAsync(p, blockContext));\r\n            }\r\n\r\n            return await this.invokeFunctionAsync(func, pms, {\r\n                moduleName: blockContext.moduleName,\r\n                line: funcCallNode.loc[0],\r\n                column: funcCallNode.loc[0]\r\n            });\r\n        }\r\n\r\n        if (node.type === \"assign\") {\r\n            const assignNode = node as AssignNode;\r\n\r\n            if (assignNode.target.type === 'getSingleVar') {\r\n                const node = assignNode.target as SetSingleVarNode;\r\n                blockContext.blockScope.set(node.name, await this.evalNodeAsync(assignNode.source, blockContext));\r\n            } else if (assignNode.target.type === 'dotObjectAccess') {\r\n                const targetNode = assignNode.target as DotObjectAccessNode;\r\n\r\n                // create a node for all but last property token\r\n                // potentially it can go to parser\r\n                const targetObjectNode = new DotObjectAccessNode(targetNode.nestedProps.slice(0, targetNode.nestedProps.length - 1), targetNode.loc);\r\n                const targetObject = await this.evalNodeAsync(targetObjectNode, blockContext) as Record<string, unknown>;\r\n\r\n                // not sure nested properties should be GetSingleVarNode\r\n                // can be factored in the parser\r\n                const lastPropertyName = (targetNode.nestedProps[targetNode.nestedProps.length - 1] as GetSingleVarNode).name\r\n\r\n                targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else if (assignNode.target.type === 'bracketObjectAccess') {\r\n                const targetNode = assignNode.target as BracketObjectAccessNode;\r\n                const keyValue = await this.evalNodeAsync(targetNode.bracketBody, blockContext) as string | number;\r\n                const targetObject = blockContext.blockScope.get(targetNode.propertyName as string) as Record<string, unknown>;\r\n\r\n                targetObject[keyValue] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n            } else {\r\n                throw Error('Not implemented Assign operation');\r\n                // get chaining calls\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        if (node.type === 'bracketObjectAccess') {\r\n            const sbNode = node as BracketObjectAccessNode;\r\n            const key = await this.evalNodeAsync(sbNode.bracketBody, blockContext) as string;\r\n            const obj = blockContext.blockScope.get(sbNode.propertyName as string) as Record<string, unknown>;\r\n            return (obj[key] === undefined) ? null : obj[key];\r\n        }\r\n\r\n        if (node.type === \"dotObjectAccess\") {\r\n            const dotObject = node as DotObjectAccessNode;\r\n\r\n            let startObject = await this.evalNodeAsync(dotObject.nestedProps[0], blockContext) as any;\r\n            for (let i = 1; i < dotObject.nestedProps.length; i++) {\r\n                const nestedProp = dotObject.nestedProps[i];\r\n\r\n                if ((dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n                    startObject = {};\r\n                }\r\n\r\n                if (nestedProp.type === 'getSingleVar') {\r\n                    startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n                } else if (nestedProp.type === 'bracketObjectAccess') {\r\n                    const node = nestedProp as BracketObjectAccessNode;\r\n                    startObject = startObject[node.propertyName] as unknown;\r\n                    startObject = startObject[await this.evalNodeAsync(node.bracketBody, blockContext) as string] as unknown;\r\n                } else if (nestedProp.type === 'funcCall') {\r\n                    const funcCallNode = nestedProp as FunctionCallNode;\r\n                    const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n                    if ((func === undefined || func === null)\r\n                        && (dotObject.nestedProps[i - 1] as unknown as IsNullCoelsing).nullCoelsing) {\r\n                        startObject = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (typeof (func) !== 'function') {\r\n                        throw Error(`'${funcCallNode.name}' is not a function or not defined.`)\r\n                    }\r\n                    const pms = []\r\n                    for (let p of funcCallNode.paramNodes || []) {\r\n                        pms.push(await this.evalNodeAsync(p, blockContext));\r\n                    }\r\n\r\n                    startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n                        moduleName: blockContext.moduleName,\r\n                        line: funcCallNode.loc[0],\r\n                        column: funcCallNode.loc[0]\r\n                    });\r\n\r\n                } else {\r\n                    throw Error(\"Can't resolve dotObjectAccess node\")\r\n                }\r\n            }\r\n\r\n            // no undefined values, make it rather null\r\n            return (startObject === undefined) ? null : startObject;\r\n        }\r\n\r\n        if (node.type === 'createObject') {\r\n            const createObjectNode = node as CreateObjectNode;\r\n            const obj = {} as Record<string, unknown>;\r\n\r\n            for (const p of createObjectNode.props) {\r\n                obj[await this.evalNodeAsync(p.name, blockContext) as string] = await this.evalNodeAsync(p.value, blockContext);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        if (node.type === 'createArray') {\r\n            const arrayNode = node as CreateArrayNode;\r\n            const res = [] as unknown[];\r\n\r\n            for (const item of arrayNode.items) {\r\n                res.push(await this.evalNodeAsync(item, blockContext));\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n    }\r\n}\r\n","import { parseDatetimeOrNull } from \"./common/utils\";\r\n\r\nexport const INITIAL_SCOPE = {\r\n    jsPython(): string {\r\n        return [`JSPython v2.1.5`, \"(c) 2021 FalconSoft Ltd. All rights reserved.\"].join('\\n')\r\n    },\r\n    dateTime: (str: number | string | any = null) => parseDatetimeOrNull(str) || new Date(),\r\n    range: range,\r\n    print: (...args: any[]) => { console.log(...args); return args.length > 0 ? args[0] : null; },\r\n    isNull: (v: any, defValue: any = null): boolean | any => defValue === null ? v === null : v || defValue,\r\n    isDate: (d: any): boolean => d instanceof Date,\r\n    isFunction: (v: any): boolean => typeof v === 'function',\r\n    isString: (v: any): boolean => typeof v === 'string',\r\n    deleteProperty: (obj: any, propName: string): boolean => delete obj[propName],\r\n    Math: Math,\r\n    Object: Object,\r\n    Array: Array,\r\n    JSON: JSON,\r\n    printExecutionContext: () => {}, // will be overriden at runtime\r\n    getExecutionContext: () => {} // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n    name: string;\r\n    properties?: { name: string, as?: string }[];\r\n    as?: string;\r\n}\r\n\r\nfunction range(start: number, stop: number = NaN, step: number = 1): number[] {\r\n    const arr: number[] = [];\r\n    const isStopNaN = isNaN(stop);\r\n    stop = isStopNaN ? start : stop;\r\n    start = isStopNaN ? 0 : start;\r\n    let i = start;\r\n    while (i < stop) {\r\n        arr.push(i);\r\n        i += step;\r\n    }\r\n    return arr;\r\n}\r\n","import {\r\n    BinOpNode, ConstNode, AstBlock, Token, ParserOptions, AstNode, Operators, AssignNode, TokenTypes,\r\n    GetSingleVarNode, FunctionCallNode, getTokenType, getTokenValue, isTokenTypeLiteral, getStartLine,\r\n    getStartColumn, getEndColumn, getEndLine, findOperators, splitTokens, DotObjectAccessNode, BracketObjectAccessNode,\r\n    findTokenValueIndex, FunctionDefNode, CreateObjectNode, ObjectPropertyInfo, CreateArrayNode, ArrowFuncDefNode,\r\n    ExpressionOperators, IfNode, ForNode, WhileNode, ImportNode, NameAlias, ContinueNode, BreakNode, ReturnNode, CommentNode,\r\n    getTokenLoc, OperationTypes, LogicalNodeItem, LogicalOperators, LogicalOpNode, ComparisonOperators, TryExceptNode, ExceptBody, RaiseNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n    readonly tokens: Token[] = [];\r\n\r\n    startLine(): number {\r\n        return getStartLine(this.tokens[0]);\r\n    }\r\n\r\n    startColumn(): number {\r\n        return getStartColumn(this.tokens[0]);\r\n    }\r\n\r\n    endLine(): number {\r\n        return getEndLine(this.tokens[this.tokens.length - 1]);\r\n    }\r\n\r\n    endColumn(): number {\r\n        return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n    }\r\n}\r\n\r\nexport class Parser {\r\n    private _currentToken: Token | null = null;\r\n    private _moduleName = '';\r\n\r\n    /**\r\n     * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n     * @param tokens tokens\r\n     * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n     */\r\n    parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n        this._moduleName = name;\r\n        const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n        if (!tokens || !tokens.length) { return ast; }\r\n\r\n        try {\r\n\r\n            // group all tokens into an Instruction lines.\r\n            const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n            // process all instructions\r\n            this.instructionsToNodes(instructions, ast);\r\n\r\n        } catch (err) {\r\n            const token = this._currentToken ?? {} as Token\r\n            throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || err)\r\n        }\r\n        return ast;\r\n    }\r\n\r\n    private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n\r\n        const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n            const instructionLines = this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));\r\n            const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, bodyAst);\r\n            return bodyAst.body;\r\n        }\r\n\r\n        const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n            result.splice(0, result.length);\r\n            findOperators(tkns, operation).forEach(r => result.push(r));\r\n            return !!result.length;\r\n        }\r\n\r\n        for (let i = 0; i < instructions.length; i++) {\r\n            const instruction = instructions[i];\r\n\r\n            // remove comments\r\n            let tt = 0;\r\n            while (tt < instruction.tokens.length) {\r\n                if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n                    instruction.tokens.splice(tt, 1);\r\n                } else {\r\n                    tt++;\r\n                }\r\n            }\r\n            if (!instruction.tokens.length) {\r\n                continue;\r\n            }\r\n\r\n            const firstToken = instruction.tokens[0];\r\n            const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n            this._currentToken = firstToken;\r\n\r\n            const logicOpIndexes: number[] = [];\r\n            const comparisonOpIndexs: number[] = [];\r\n            const assignTokenIndexes: number[] = [];\r\n\r\n            if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n                ast.body.push(new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'def'\r\n                || (getTokenValue(firstToken) === \"async\" && getTokenValue(secondToken) === \"def\")) {\r\n\r\n                const isAsync = getTokenValue(firstToken) === \"async\";\r\n                const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n                const paramsTokens = instruction.tokens.slice(\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n                    instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n                );\r\n\r\n                const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for def`)\r\n                }\r\n\r\n                const instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));\r\n                const funcAst = {\r\n                    name: funcName,\r\n                    body: [] as AstNode[],\r\n                    funcs: [] as AstNode[]\r\n                } as AstBlock;\r\n                this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n                ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])))\r\n\r\n            } else if (getTokenValue(firstToken) === 'if') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                if (instructions.length > i + 1\r\n                    && getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                    && getTokenValue(instructions[i + 1].tokens[1]) === ':') {\r\n                    elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    i++;\r\n                }\r\n\r\n                ast.body.push(new IfNode(conditionNode, ifBody, elseBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'try') {\r\n\r\n                if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n                    throw (`'try' statement should be followed by ':'`)\r\n                }\r\n\r\n                const tryBody = getBody(instruction.tokens, 2);\r\n                const excepts: ExceptBody[] = [];\r\n\r\n                let elseBody: AstNode[] | undefined = undefined;\r\n                let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n                while (instructions.length > i + 1\r\n                    && (\r\n                        getTokenValue(instructions[i + 1].tokens[0]) === 'else'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'except'\r\n                        || getTokenValue(instructions[i + 1].tokens[0]) === 'finally'\r\n                    )\r\n                ) {\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n                        if (elseBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        elseBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n                        if (finallyBody) {\r\n                            throw new Error(`Only one 'else' is allowed in a 'try'`)\r\n                        }\r\n\r\n                        finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n                    }\r\n\r\n                    if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n\r\n                        const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n                        const except = {} as ExceptBody;\r\n\r\n                        if (endIndex === 2) {\r\n                            except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n                        } else if (endIndex === 3) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[2]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex === 4) {\r\n                            except.error = {\r\n                                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                                alias: getTokenValue(instructions[i + 1].tokens[3]),\r\n                            } as NameAlias;\r\n                        } else if (endIndex !== 1) {\r\n                            throw new Error(`Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`)\r\n                        }\r\n\r\n                        except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n                        excepts.push(except);\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n\r\n                if (!excepts.length) {\r\n                    throw new Error('Except: is missing');\r\n                }\r\n\r\n                ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'continue') {\r\n                ast.body.push(new ContinueNode());\r\n            } else if (getTokenValue(firstToken) === 'break') {\r\n                ast.body.push(new BreakNode());\r\n            } else if (getTokenValue(firstToken) === 'return') {\r\n                ast.body.push(new ReturnNode(\r\n                    instruction.tokens.length > 1 ? this.createExpressionNode(instruction.tokens.slice(1)) : undefined,\r\n                    getTokenLoc(firstToken))\r\n                );\r\n            } else if (getTokenValue(firstToken) === 'raise') {\r\n\r\n                if (instruction.tokens.length === 1) {\r\n                    throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n                }\r\n                const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n                const errorMessage = (\r\n                    instruction.tokens.length == 5\r\n                    && getTokenValue(instruction.tokens[2]) === \"(\"\r\n                    && getTokenValue(instruction.tokens[4]) === \")\"\r\n                ) ? getTokenValue(instruction.tokens[3]) as string\r\n                    : undefined;\r\n\r\n                ast.body.push(new RaiseNode(errorName, errorMessage, getTokenLoc(firstToken)));\r\n            } else if (getTokenValue(firstToken) === 'for') {\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for if`)\r\n                }\r\n\r\n                const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n                const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef))\r\n                const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)))\r\n\r\n            } else if (getTokenValue(firstToken) === 'while') {\r\n\r\n                const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n                if (endDefOfDef === -1) {\r\n                    throw (`Can't find : for [while]`)\r\n                }\r\n\r\n\r\n                const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n                const conditionNode = (findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)) ?\r\n                    this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n                    :\r\n                    this.createExpressionNode(conditionTokens);\r\n\r\n                const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n                ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n\r\n            } else if (getTokenValue(firstToken) === 'import') {\r\n                let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n                if (asIndex < 0) {\r\n                    asIndex = instruction.tokens.length;\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, asIndex).map(t => getTokenValue(t)).join(''),\r\n                    alias: instruction.tokens.slice(asIndex + 1).map(t => getTokenValue(t)).join('') || undefined\r\n                } as NameAlias;\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n                ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)))\r\n            } else if (getTokenValue(firstToken) === 'from') {\r\n                const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n                if (importIndex < 0) {\r\n                    throw Error(`'import' must follow 'from'`);\r\n                }\r\n\r\n                const module = {\r\n                    name: instruction.tokens.slice(1, importIndex).map(t => getTokenValue(t)).join('')\r\n                } as NameAlias;\r\n\r\n                const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',')\r\n                    .map(t => {\r\n                        return {\r\n                            name: getTokenValue(t[0]),\r\n                            alias: (t.length === 3) ? getTokenValue(t[2]) : undefined\r\n                        } as NameAlias\r\n                    });\r\n\r\n                const body = {} as AstBlock; // empty for now\r\n\r\n                ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)))\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n                const assignTokens = splitTokens(instruction.tokens, '=');\r\n                const target = this.createExpressionNode(assignTokens[0]);\r\n                const source = this.createExpressionNode(assignTokens[1]);\r\n                ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n            } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n                ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n            } else {\r\n                ast.body.push(this.createExpressionNode(instruction.tokens))\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n        // if expression is in brackets, then we need clean brackets\r\n        if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n            begin++;\r\n            end--;\r\n        }\r\n\r\n        return a.slice(begin, end);\r\n    }\r\n\r\n    private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n        const start = 0;\r\n\r\n        let leftNode: AstNode | null = null;\r\n        for (let i = 0; i < indexes.length; i++) {\r\n            const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n            leftNode = (leftNode) ? leftNode : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]))\r\n\r\n            const endInd = (i + 1 < indexes.length) ? indexes[i + 1] : tokens.length;\r\n            const rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd))\r\n\r\n            leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        return leftNode as AstNode;\r\n    }\r\n\r\n    private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n        let start = 0;\r\n        const logicItems: LogicalNodeItem[] = [];\r\n        for (let i = 0; i < logicOp.length; i++) {\r\n            const opToken = tokens[logicOp[i]];\r\n            const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n            logicItems.push({\r\n                node: this.createExpressionNode(logicalSlice),\r\n                op: getTokenValue(opToken) as LogicalOperators\r\n            });\r\n\r\n            start = logicOp[i] + 1;\r\n        }\r\n\r\n        logicItems.push({\r\n            node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n        } as LogicalNodeItem);\r\n\r\n        const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n        return lop;\r\n    }\r\n\r\n    private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n        const lines: InstructionLine[] = [];\r\n\r\n        let column = 0;\r\n        let currentLine = startLine;\r\n        let line = new InstructionLine();\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n            const sLine = getStartLine(token);\r\n            const sColumn = getStartColumn(token);\r\n            const value = getTokenValue(token);\r\n            this._currentToken = token;\r\n\r\n            if (sLine >= startLine) {\r\n\r\n                if (currentLine !== sLine) {\r\n                    currentLine = sLine;\r\n                }\r\n\r\n                if (column === sColumn && !\")}]\".includes(value as string)) {\r\n                    currentLine = sLine;\r\n                    lines.push(line);\r\n                    line = new InstructionLine();\r\n                }\r\n\r\n                line.tokens.push(token);\r\n\r\n                // first line defines a minimum indent\r\n                if (column === 0) {\r\n                    column = sColumn;\r\n                }\r\n\r\n                // stop looping through if line has less indent\r\n                // it means the corrent block finished\r\n                if (sColumn < column) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (line.tokens.length) {\r\n            lines.push(line)\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    private createExpressionNode(tokens: Token[], prevNode: AstNode | null = null): AstNode {\r\n        if (tokens.length === 0) {\r\n            throw new Error(`Tokens length can't empty.`)\r\n        }\r\n        const lastToken = tokens[tokens.length - 1];\r\n        if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n            throw new Error(`Unexpected symbol ';' in the end`)\r\n        }\r\n\r\n        this._currentToken = tokens[0];\r\n\r\n        // const or variable\r\n        if (tokens.length === 1\r\n            || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')\r\n        ) {\r\n            const firstToken = tokens[0];\r\n            const tokenType = getTokenType(firstToken);\r\n\r\n            if (isTokenTypeLiteral(tokenType)) {\r\n                return new ConstNode(firstToken);\r\n            } else if (tokenType === TokenTypes.Identifier) {\r\n                return new GetSingleVarNode(firstToken, tokens.length === 2 && getTokenValue(tokens[1]) === '?' || undefined);\r\n            }\r\n\r\n            throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n        }\r\n\r\n        // arrow function\r\n        const arrowFuncParts = splitTokens(tokens, '=>');\r\n        if (arrowFuncParts.length > 1) {\r\n            const pArray = getTokenValue(arrowFuncParts[0][0]) === '(' ?\r\n                arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n                : arrowFuncParts[0];\r\n            const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n            const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n            const funcAst = {\r\n                name: this._moduleName,\r\n                body: [] as AstNode[],\r\n                funcs: [] as AstNode[]\r\n            } as AstBlock;\r\n            this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n            return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // comparison operations\r\n        const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n        if (comparissonIndexes.length) {\r\n            return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n        }\r\n\r\n        // create arithmetic expression\r\n        const ops = findOperators(tokens);\r\n        if (ops.length) {\r\n\r\n            let prevNode: AstNode | null = null;\r\n            for (let i = 0; i < ops.length; i++) {\r\n                const opIndex = ops[i];\r\n                const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n                let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n                    let rightNode: AstNode | null = null;\r\n                    // iterate through all continuous '*', '/' operations\r\n                    do {\r\n                        const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n                        const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n                        const rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);\r\n\r\n                        const left2 = this.createExpressionNode(leftSlice2);\r\n                        const right2 = this.createExpressionNode(rightSlice2);\r\n                        rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n                        i++;\r\n                        nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n                        nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n                    }\r\n                    while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'))\r\n\r\n                    // add up result\r\n                    if (prevNode === null) {\r\n                        const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n                        prevNode = this.createExpressionNode(leftSlice);\r\n                    }\r\n                    prevNode = new BinOpNode(prevNode, op as ExpressionOperators, rightNode, getTokenLoc(tokens[0]))\r\n\r\n                } else {\r\n                    const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n                    const rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);\r\n                    const left: AstNode = prevNode || this.createExpressionNode(leftSlice, prevNode);\r\n                    const right = this.createExpressionNode(rightSlice);\r\n                    prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n                }\r\n            }\r\n\r\n            if (prevNode === null) {\r\n                throw Error(`Can't create node ...`)\r\n            }\r\n\r\n            return prevNode;\r\n        }\r\n\r\n        // create DotObjectAccessNode\r\n        const subObjects = splitTokens(tokens, '.');\r\n        if (subObjects.length > 1) {\r\n            return new DotObjectAccessNode(subObjects.map(tkns => this.createExpressionNode(tkns)), getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // create function call node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n\r\n            const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n            if (isNullCoelsing) {\r\n                // remove '?'\r\n                tokens.pop();\r\n            }\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsTokens = splitTokens(paramsTokensSlice, ',')\r\n            const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n            const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n            node.nullCoelsing = isNullCoelsing || undefined;\r\n            return node;\r\n        }\r\n\r\n        // create Object Node\r\n        if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n            const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n            const props = [] as ObjectPropertyInfo[];\r\n            for (let i = 0; i < keyValueTokens.length; i++) {\r\n                const keyValue = splitTokens(keyValueTokens[i], ':');\r\n                if (keyValue.length === 1) {\r\n                    const pInfo = {\r\n                        name: new ConstNode(keyValue[0][0]),\r\n                        value: this.createExpressionNode(keyValue[0])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else if (keyValue.length === 2) {\r\n\r\n                    let name: AstNode | null = null;\r\n                    const namePart = keyValue[0];\r\n\r\n                    if (namePart.length === 1) {\r\n                        name = new ConstNode(namePart[0]);\r\n                    } else if (getTokenValue(namePart[0]) === '['\r\n                        && getTokenValue(namePart[namePart.length - 1]) === ']') {\r\n                        name = this.createExpressionNode(namePart.slice(1, namePart.length - 1))\r\n                    } else {\r\n                        throw new Error(`Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`)\r\n                    }\r\n\r\n                    const pInfo = {\r\n                        name,\r\n                        value: this.createExpressionNode(keyValue[1])\r\n                    } as ObjectPropertyInfo;\r\n\r\n                    props.push(pInfo);\r\n                } else {\r\n                    throw Error('Incorrect JSON')\r\n                }\r\n            }\r\n\r\n            return new CreateObjectNode(props, getTokenLoc(tokens[0]))\r\n        }\r\n\r\n        // create Array Node\r\n        if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n            const items = splitTokens(tokens.splice(1, tokens.length - 2), ',')\r\n                .map(tkns => this.createExpressionNode(tkns));\r\n\r\n            return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        // bracket access object node\r\n        if (tokens.length > 2 && getTokenValue(tokens[1]) === '[') {\r\n            const name = getTokenValue(tokens[0]) as string;\r\n            const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n            const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n            return new BracketObjectAccessNode(name, paramsNodes, false, getTokenLoc(tokens[0]));\r\n        }\r\n\r\n        throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n    }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n    '\\n': ['\\n'],\r\n    '=': ['=', '==', '=>'],\r\n\r\n    '+': ['+', '++', '+='],\r\n    '-': ['-', '--', '-='],\r\n    '*': ['*', '**', '*='],\r\n    '/': ['/', '//', '/='],\r\n\r\n    '.': ['.'],\r\n    '?': ['?'],\r\n    '!': ['!='],\r\n    ':': [':'],\r\n    ',': [','],\r\n\r\n    '>': ['>', '>='],\r\n    '<': ['<', '<=', '<>'],\r\n\r\n    '(': ['('],\r\n    ')': [')'],\r\n    '{': ['{'],\r\n    '}': ['}'],\r\n    '[': ['['],\r\n    ']': [']'],\r\n};\r\n\r\nconst Keywords: string[] = [\"async\", \"def\", \"for\", \"while\", \"if\", \"return\", \"in\"];\r\n\r\nexport class Tokenizer {\r\n    private _startLine = 1;\r\n    private _startColumn = 1;\r\n    private _currentLine = 1;\r\n    private _currentColumn = 1;\r\n    private _tokenText = '';\r\n    private _cursor = 0;\r\n    private _script = \"\";\r\n\r\n    private get tokenText(): string {\r\n        return this._tokenText;\r\n    }\r\n    private set tokenText(value: string) {\r\n        if (!this._tokenText && value) {\r\n            this._startLine = this._currentLine;\r\n            this._startColumn = this._currentColumn;\r\n        }\r\n        this._tokenText = value;\r\n    }\r\n\r\n    /**\r\n     * Splits script code into a tokens\r\n     * @param script A jsPython text\r\n     */\r\n    tokenize(script: string): Token[] {\r\n        if (!script || !script.length) { return []; }\r\n\r\n        script = script\r\n            .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n            .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n        this._script = script;\r\n\r\n        this._cursor = 0;\r\n        this._startLine = 1;\r\n        this._startColumn = 1;\r\n        this._currentLine = 1;\r\n        this._currentColumn = 1;\r\n\r\n        const tokens: Token[] = [];\r\n\r\n        let first = true;\r\n        // handle initial spaces\r\n        while (script[this._cursor] === '\\n') {\r\n            this.incrementCursor();\r\n            if (first) {\r\n                this._currentLine++;\r\n                first = false;\r\n            }\r\n            this._currentColumn = 1;\r\n        }\r\n\r\n        do {\r\n            const symbol = script[this._cursor];\r\n\r\n            if (symbol == ' ' && this.tokenText.length !== 0) {\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                continue;\r\n            } else if ((SeparatorsMap[symbol] !== undefined) && !this.isPartOfNumber(symbol, tokens)) {\r\n                // handle numbers with floating point e.g. 3.14\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n                this.tokenText = symbol;\r\n\r\n                const sepsMap = SeparatorsMap[symbol];\r\n\r\n                if (sepsMap.length >= 1) {\r\n                    // process longer operators\r\n                    while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                    }\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n\r\n            } else if (symbol === '#') {\r\n\r\n                let first = true;\r\n                while (script[this.incrementCursor()] !== '\\n') {\r\n                    this.tokenText += script[this._cursor];\r\n\r\n                    // correct start column\r\n                    if (first) {\r\n                        first = false;\r\n                        this._startColumn = this._startColumn - 1\r\n                    }\r\n\r\n                    if (this._cursor + 1 >= script.length) break;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n\r\n            } else if (symbol === '\"' || symbol === \"'\") {\r\n                // remember either it is single or double quote\r\n                const q = symbol;\r\n                // we are not expecting token to be added here.\r\n                // it should pass a failt to parser\r\n                this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n                // handle \"\"\" comment \"\"\"\"\r\n                if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n                    const cLine = this._currentLine;\r\n                    const cColumn = this._currentColumn;\r\n                    this.incrementCursor(2);\r\n                    const passCond = true;\r\n                    while (passCond) {\r\n                        this.tokenText += script[this.incrementCursor()];\r\n                        if (this._cursor + 3 >= script.length\r\n                            || (script[this._cursor + 1] === q && script[this._cursor + 2] === q && script[this._cursor + 3] === q)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    // a special case when multiline string\r\n                    this._startLine = cLine;\r\n                    this._startColumn = cColumn;\r\n\r\n                    this.incrementCursor(3);\r\n                } else {\r\n                    while (script[this.incrementCursor()] !== q) {\r\n                        this.tokenText += script[this._cursor];\r\n                        if (this._cursor + 1 >= script.length) break;\r\n                    }\r\n\r\n                    //start column needs to take into account a begining quote, not just a string\r\n                    this._startColumn--;\r\n                }\r\n\r\n                // a special case when empty string\r\n                if (this.tokenText.length === 0) {\r\n                    this._startLine = this._currentLine;\r\n                    this._startColumn = this._currentColumn;\r\n                }\r\n                this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n            } else if (symbol != ' ') {\r\n                this.tokenText += symbol;\r\n            }\r\n        }\r\n        while (this.incrementCursor() < script.length)\r\n\r\n        this.processToken(this.tokenText, tokens);\r\n\r\n        return tokens;\r\n    }\r\n\r\n    private incrementCursor(count = 1): number {\r\n        for (let i = 0; i < count; i++) {\r\n            this._cursor = this._cursor + 1;\r\n            if (this._script[this._cursor] === '\\n') {\r\n                this._currentLine++;\r\n                this._currentColumn = 0;\r\n            } else {\r\n                this._currentColumn++;\r\n            }\r\n        }\r\n\r\n        return this._cursor;\r\n    }\r\n\r\n    private recognizeToken(tokenText: string, type: TokenTypes | null = null): { value: string | number | boolean | null, type: TokenTypes } {\r\n\r\n        let value: string | number | boolean | null = tokenText;\r\n\r\n        if (type === null) {\r\n            if (tokenText === 'null') {\r\n                type = TokenTypes.LiteralNull;\r\n                value = null;\r\n            } else if (tokenText === 'true' || tokenText === 'false') {\r\n                type = TokenTypes.LiteralBool;\r\n                value = tokenText === 'true';\r\n            } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n                type = TokenTypes.LiteralNumber;\r\n                value = this.parseNumberOrNull(tokenText);\r\n            } else if (Keywords.indexOf(tokenText) >= 0) {\r\n                type = TokenTypes.Keyword;\r\n            } else {\r\n                type = TokenTypes.Identifier\r\n            }\r\n        }\r\n\r\n        return {\r\n            value: value,\r\n            type: type\r\n        }\r\n\r\n    }\r\n\r\n    private processToken(strToken: string, tokens: Token[], allowEmptyString = false, type: TokenTypes | null = null): string {\r\n        // ignore empty tokens\r\n        if (!strToken.length && !allowEmptyString || strToken === '\\n') return \"\";\r\n\r\n        const token = this.recognizeToken(strToken, type);\r\n        tokens.push([token.value, Uint16Array.of(token.type as number,\r\n            this._startLine, this._startColumn,\r\n            this._currentLine, this._currentColumn)] as Token)\r\n        return \"\";\r\n    }\r\n\r\n    private parseNumberOrNull(value: string | number): number | null {\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n\r\n        if (!value || typeof value !== 'string') {\r\n            return null;\r\n        }\r\n\r\n        value = value.trim();\r\n\r\n        // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n        for (let i = value.length - 1; i >= 0; i--) {\r\n            const d = value.charCodeAt(i);\r\n            if (d < 48 || d > 57) {\r\n                // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n                if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        const res = parseFloat(value);\r\n        return !isNaN(res) ? res : null;\r\n    }\r\n\r\n    private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n        if (symbol === '-' && !this.tokenText.length) {\r\n            // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n            const prevToken = (currentTokens.length !== 0) ? currentTokens[currentTokens.length - 1] : null;\r\n            return prevToken === null || (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')');\r\n        } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","import { AstBlock, ImportNode, Token } from './common';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => any;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n    return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n    private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n    private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n    private packageLoader?: PackageLoader;\r\n    private moduleLoader?: ModuleLoader;\r\n\r\n    constructor() { }\r\n\r\n    static create(): Interpreter {\r\n        return new Interpreter();\r\n    }\r\n\r\n    get initialExecutionContext(): Record<string, unknown> {\r\n        return this.initialScope;\r\n    }\r\n\r\n    get lastExecutionContext(): Record<string, unknown> | null {\r\n        return this._lastExecutionContext;\r\n    }\r\n\r\n    cleanUp(): void {\r\n        this._lastExecutionContext = null;\r\n    }\r\n\r\n    jsPythonInfo(): string {\r\n        return INITIAL_SCOPE.jsPython();\r\n    }\r\n\r\n    tokenize(script: string): Token[] {\r\n        const tokenizer = new Tokenizer();\r\n        return tokenizer.tokenize(script);\r\n    }\r\n\r\n    parse(script: string, moduleName: string = 'main.jspy'): AstBlock {\r\n        const tokenizer = new Tokenizer();\r\n        const parser = new Parser();\r\n        const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n        return jspyAst;\r\n    }\r\n\r\n    eval(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): unknown {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = new Evaluator().evalBlock(ast, blockContext);\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return func();\r\n        }\r\n    }\r\n\r\n    async evalAsync(codeOrAst: string | AstBlock, scope: Record<string, unknown> = {}\r\n        , entryFunctionName: string = '', moduleName: string = 'main.jspy'): Promise<unknown> {\r\n        const ast = (typeof codeOrAst === 'string') ? this.parse(codeOrAst as string, moduleName) : codeOrAst as AstBlock;\r\n        const evaluator = new EvaluatorAsync();\r\n        const blockContext = {\r\n            moduleName: moduleName,\r\n            blockScope: new Scope(scope)\r\n        } as BlockContext;\r\n\r\n        blockContext.blockScope.set('printExecutionContext', () => console.log(blockContext.blockScope.getScope()));\r\n        blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n        this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n        const result = await evaluator\r\n            .registerModuleParser(async (modulePath) => await this.moduleParser(modulePath))\r\n            .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n                // this line will not be required when we have move package loaders to the evaluator\r\n                const newContext = this.assignLegacyImportContext(ast, scope);\r\n\r\n                const moduleContext = { moduleName, blockScope: new Scope(newContext) }\r\n                moduleContext.blockScope.set('printExecutionContext', () => console.log(moduleContext.blockScope.getScope()));\r\n                moduleContext.blockScope.set('getExecutionContext', () => moduleContext.blockScope.getScope());\r\n                return moduleContext;\r\n            })\r\n            .evalBlockAsync(ast, blockContext);\r\n\r\n        if (!entryFunctionName || !entryFunctionName.length) {\r\n            return result;\r\n        } else {\r\n            const func = blockContext.blockScope.get(entryFunctionName);\r\n            if (typeof func !== 'function') {\r\n                throw Error(`Function ${entryFunctionName} does not exists or not a function`)\r\n            }\r\n            return await func();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compatibility method! Will be deprecated soon\r\n     */\r\n    async evaluate(script: string, context: object = {}, entryFunctionName: string = ''\r\n        , moduleName: string = 'main.jspy'): Promise<any> {\r\n        if (!script || !script.length) { return null; }\r\n        const ast = this.parse(script, moduleName);\r\n\r\n        context = (context && typeof context === 'object') ? context : {};\r\n        context = this.assignLegacyImportContext(ast, context);\r\n\r\n        const globalScope = {\r\n            ...this.initialScope,\r\n            ...context\r\n        } as Record<string, unknown>;\r\n\r\n        return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName);\r\n    }\r\n\r\n    registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.packageLoader = loader;\r\n        } else {\r\n            throw Error('PackagesLoader');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n        if (typeof loader === 'function') {\r\n            this.moduleLoader = loader;\r\n        } else {\r\n            throw Error('ModuleLoader should be a function');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    addFunction(funcName: string, fn: (...args: any[]) => void | any | Promise<any>): Interpreter {\r\n        this.initialScope[funcName] = fn;\r\n        return this;\r\n    }\r\n\r\n    assignGlobalContext(obj: object): Interpreter {\r\n        Object.assign(this.initialScope, obj);\r\n        return this;\r\n    }\r\n\r\n    hasFunction(scripts: string = '', funcName: string): boolean {\r\n        return scripts.indexOf(`def ${funcName}`) > -1;\r\n    }\r\n\r\n    private assignLegacyImportContext(ast: AstBlock, context: object): Record<string, unknown> {\r\n\r\n        const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n            return {\r\n                name: im.module.name,\r\n                as: im.module.alias,\r\n                properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n            } as PackageToImport\r\n        }\r\n\r\n        const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n        const jsImport = importNodes\r\n            .filter(im => !im.module.name.startsWith('/'))\r\n            .map(im => nodeToPackage(im));\r\n\r\n        if (jsImport.length && this.packageLoader) {\r\n            const libraries = this.packageResolver(jsImport);\r\n            context = { ...context, ...libraries };\r\n        }\r\n\r\n        return context as Record<string, unknown>;\r\n    }\r\n\r\n    private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n        if (!this.moduleLoader) {\r\n            throw new Error('Module Loader is not registered')\r\n        }\r\n\r\n        const content = await this.moduleLoader(modulePath);\r\n        return this.parse(content, modulePath);\r\n    }\r\n\r\n    private packageResolver(packages: PackageToImport[]): object {\r\n        if (!this.packageLoader) {\r\n            throw Error('Package loader not provided.');\r\n        }\r\n        const libraries: any = {};\r\n        packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n            const lib = this.packageLoader && this.packageLoader(name);\r\n            if (properties?.length) {\r\n                properties.forEach((prop) => {\r\n                    libraries[prop.as || prop.name] = lib[prop.name];\r\n                })\r\n            } else if (as) {\r\n                libraries[as] = lib;\r\n            } else {\r\n                libraries[name] = lib;\r\n            }\r\n            if (as) {\r\n                libraries[as] = lib;\r\n            }\r\n        });\r\n        return libraries;\r\n    }\r\n\r\n}\r\n"],"names":["OperationTypes","TokenTypes","OperatorsMap","Arithmetic","Comparison","and","Logical","or","in","Membership","Assignment","OperationFuncs","l","r","arithmeticOperation","comparissonOperation","logicalOperation","op","includes","String","Array","isArray","Error","membershipOperation","Math","pow","getTokenType","token","getTokenValue","getTokenLoc","subarray","getStartLine","getStartColumn","splitTokens","tokens","separator","result","length","sepIndexes","findTokenValueIndexes","value","start","i","ind","push","slice","findTokenValueIndex","predicate","LiteralString","skipInnerBrackets","opIndexes","tValue","findOperators","operationType","undefined","openChar","closeChar","innerBrackets","tokenValue","type","this","target","source","loc","_super","_this","__extends","AstNode","comment","returnValue","errorName","errorMessage","name","paramNodes","funcAst","params","isAsync","conditionNode","ifBody","elseBody","tryBody","exepts","finallyBody","sourceArray","itemVarName","body","condition","module","parts","nullCoelsing","nestedProps","props","items","propertyName","bracketBody","nullCoalescing","left","right","jspyErrorMessage","error","line","column","message","Object","setPrototypeOf","JspyTokenizerError","prototype","JspyParserError","JspyEvalError","JspyError","cloneContext","context","moduleName","blockScope","clone","initialScope","scope","Scope","key","path","Evaluator","ast","blockContext","lastResult","node","funcDef","set","_i","args","jspyFuncInvoker","_a","funcs","_c","_b","evalNode","returnCalled","res","returnObject","continueCalled","breakCalled","err","assign","argValue","evalBlock","func","fps","raiseNode","returnNode","name_2","get","charAt","binOpNode","logicalGroups","gResult","eg","arrowFuncDef_1","funcCallNode","pms","map","n","invokeFunction","assignNode","node_1","targetNode","targetObjectNode","DotObjectAccessNode","keyValue","sbNode","obj","dotObject","startObject","nestedProp","node_2","bind","_h","p","_k","_j","item","whileNode","forNode","array","tryNode","name_1","firstExept","catchBody","ctx","alias","ifNode","Promise","reject","EvaluatorAsync","moduleParser","blockContextFactory","newScope","invoker","jspyFuncInvokerAsync","_e","_d","importNode","startsWith","moduleAst","_f","moduleBlockContext","evalBlockAsync","getScope","defaultModuleName","assignFunctionsToScope","evalNodeAsync","err_1","filter","f","indexOf","substring","lastIndexOf","_6","err_2","_g","invokeFunctionAsync","_m","_l","targetObject","lastPropertyName","_p","_q","_r","_s","_t","_v","_u","_x","_w","_z","_y","_0","_1","_3","_2","_5","_4","INITIAL_SCOPE","jsPython","join","dateTime","str","Date","isNaN","valueOf","strValue","parseMonth","mm","NaN","m","parseInt","correctYear","yy","validDateOrNull","yyyy","month","day","hours","mins","ss","dd","strTokens","replace","toLowerCase","split","dt","parseFloat","d","parseDatetimeOrNull","range","stop","step","arr","isStopNaN","print","console","log","isNull","v","defValue","isDate","isFunction","isString","deleteProperty","propName","JSON","printExecutionContext","getExecutionContext","InstructionLine","Parser","_moduleName","instructions","tokensToInstructionLines","instructionsToNodes","_currentToken","getBody","startTokenIndex","instructionLines","bodyAst","findIndexes","tkns","operation","splice","forEach","instruction","tt","Comment","firstToken","secondToken","logicOpIndexes","CommentNode","funcName","findIndex","t","endDefOfDef","FunctionDefNode","conditionTokens","groupLogicalOperations","createExpressionNode","IfNode","excepts","endIndex","except","TryExceptNode","ContinueNode","BreakNode","ReturnNode","RaiseNode","forBody","ForNode","WhileNode","asIndex","module_1","ImportNode","importIndex","module_2","assignTokens","AssignNode","a","begin","end","indexes","leftNode","opToken","sliceWithBrackets","endInd","rightNode","BinOpNode","logicOp","logicItems","logicalSlice","LogicalOpNode","startLine","lines","sLine","sColumn","prevNode","lastToken","tokenType","LiteralNumber","LiteralBool","LiteralNull","isTokenTypeLiteral","ConstNode","Identifier","GetSingleVarNode","stringify","arrowFuncParts","ArrowFuncDefNode","comparissonIndexes","groupComparisonOperations","ops","prevNode_1","opIndex","nextOpIndex","nextOp","leftSlice","rightSlice","nextOpIndex2","leftSlice2","rightSlice2","left2","right2","subObjects","isNullCoelsing","pop","paramsNodes","paramsTokensSlice","FunctionCallNode","keyValueTokens","pInfo","namePart","CreateObjectNode","CreateArrayNode","name_3","BracketObjectAccessNode","SeparatorsMap","Keywords","Tokenizer","_tokenText","_startLine","_currentLine","_startColumn","_currentColumn","script","RegExp","_script","_cursor","first","incrementCursor","symbol","tokenText","isPartOfNumber","first_1","processToken","q","cLine","cColumn","sepsMap","Operator","count","parseNumberOrNull","Keyword","strToken","allowEmptyString","recognizeToken","Uint16Array","of","trim","charCodeAt","currentTokens","prevToken","Interpreter","_lastExecutionContext","tokenize","tokenizer","parse","codeOrAst","entryFunctionName","evaluator","registerModuleParser","modulePath","registerBlockContextFactory","newContext","assignLegacyImportContext","moduleContext","globalScope","__assign","evalAsync","loader","packageLoader","moduleLoader","fn","scripts","jsImport","im","as","properties","nodeToPackage","libraries","packageResolver","content","packages","lib","prop","create"],"mappings":"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"}